#!/usr/bin/env python3# -*- coding: utf-8 -*-"""validate_odp.py ― ODP (OpenDocument Presentation) バリデーションスクリプト目的:  - ODPがGoogleスライドでも崩れず表示されるための要件を自動チェック  - ZIP構造, manifest, XML/名前空間, スタイル/レイアウト, スライド, 画像埋め込み, 互換性 など使い方:  python validate_odp.py path/to/file.odp --expected-pages 12 --master Default --layout pm1戻り値:  - 終了コード0: FAILなし  - 終了コード1: 1つ以上のFAILあり"""import argparseimport ioimport reimport sysimport zipfilefrom collections import defaultdictfrom math import isfinitetry:    from lxml import etreeexcept ImportError:    print("lxml が必要です。pip install lxml を実行してください。", file=sys.stderr)    sys.exit(2)NS = {    "office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",    "draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",    "presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",    "text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",    "xlink": "http://www.w3.org/1999/xlink",    "svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",    "style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",    "fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",    "manifest": "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",    "dc": "http://purl.org/dc/elements/1.1/",    "meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",}UNIT_TO_CM = {    "cm": 1.0,    "mm": 0.1,    "in": 2.54,    "pt": 2.54 / 72.0,    "px": 2.54 / 96.0,  # 96dpi仮定}def parse_length_to_cm(s):    if not s:        return None    m = re.fullmatch(r"\s*([0-9]*\.?[0-9]+)\s*(cm|mm|in|pt|px)\s*", s)    if not m:        return None    val = float(m.group(1))    unit = m.group(2)    return val * UNIT_TO_CM[unit]class Results:    def __init__(self):        self.items = []  # (level, code, message)    def add(self, level, code, msg):        self.items.append((level, code, msg))    def stats(self):        d = defaultdict(int)        for lvl, _, _ in self.items:            d[lvl] += 1        return d    def had_fail(self):        return any(lvl == "FAIL" for lvl, _, _ in self.items)    def dump(self, out=sys.stdout):        for lvl, code, msg in self.items:            print(f"[{lvl}] {code}: {msg}", file=out)def load_xml_from_zip(zf: zipfile.ZipFile, name: str, results: Results):    try:        data = zf.read(name)    except KeyError:        results.add("FAIL", "ZIP_MISSING", f"ZIP内に {name} がありません")        return None    try:        return etree.parse(io.BytesIO(data))    except Exception as e:        results.add("FAIL", "XML_PARSE", f"{name} のXMLパースに失敗: {e}")        return Nonedef check_zip_structure(zf: zipfile.ZipFile, results: Results):    infos = zf.infolist()    if not infos:        results.add("FAIL", "ZIP_EMPTY", "ZIPが空です")        return    # mimetype: 先頭・非圧縮    first = infos[0]    if first.filename != "mimetype":        results.add("FAIL", "MIMETYPE_FIRST", "mimetype がZIP先頭にありません")    else:        if first.compress_type != zipfile.ZIP_STORED:            results.add("FAIL", "MIMETYPE_STORED", "mimetype は非圧縮(ZIP_STORED)である必要があります")        # 内容確認        try:            content = zf.read("mimetype").decode("utf-8").strip()            if content != "application/vnd.oasis.opendocument.presentation":                results.add("FAIL", "MIMETYPE_CONTENT",                           f"mimetype 内容が不正: {content}")            else:                results.add("PASS", "MIMETYPE_OK", "mimetype 位置・圧縮・内容OK")        except Exception as e:            results.add("FAIL", "MIMETYPE_READ", f"mimetype の読込失敗: {e}")def check_manifest(zf: zipfile.ZipFile, results: Results):    tree = load_xml_from_zip(zf, "META-INF/manifest.xml", results)    if tree is None:        return None, None    root = tree.getroot()    if root.tag != f"{{{NS['manifest']}}}manifest":        results.add("FAIL", "MANIFEST_ROOT", "manifest ルート要素が manifest:manifest ではありません")    # すべての file-entry を取得    entries = []    for fe in root.findall("manifest:file-entry", namespaces=NS):        full = fe.get(f"{{{NS['manifest']}}}full-path")        mtype = fe.get(f"{{{NS['manifest']}}}media-type")        entries.append((full, mtype))    if not entries:        results.add("FAIL", "MANIFEST_EMPTY", "manifest に file-entry がありません")    else:        results.add("PASS", "MANIFEST_ENTRIES", f"manifest に {len(entries)} 個のエントリ")    # 必須ファイル確認    must = ["content.xml", "styles.xml", "meta.xml", "settings.xml"]    present = {full for full, _ in entries}    for m in must:        if m not in present:            results.add("FAIL", "MANIFEST_MISSING", f"manifest に {m} がありません")    # ZIP存在とmanifest整合    zip_names = set(i.filename for i in zf.infolist())    # manifestは "/" も含むがZIP実体は持たないので除外    for full, _ in entries:        if full == "/":            continue        if full not in zip_names:            results.add("FAIL", "MANIFEST_ORPHAN", f"manifest にあるがZIPに存在しない: {full}")    # 逆：ZIPにあるのにmanifestにない    for zn in zip_names:        if zn == "mimetype":            continue        # ODP実装によりmanifestに載らないものがあるのは非推奨なので検出        if zn not in present:            results.add("WARN", "ZIP_ORPHAN", f"ZIP にあるが manifest に未掲載: {zn}")    return entries, presentdef check_content_xml(zf: zipfile.ZipFile, results: Results, expected_pages=None):    tree = load_xml_from_zip(zf, "content.xml", results)    if tree is None:        return None, None    root = tree.getroot()    # ルート/構造    if root.tag != f"{{{NS['office']}}}document-content":        results.add("FAIL", "CONTENT_ROOT", "content.xml のルートが office:document-content ではありません")    # 必要prefixの宣言確認（nsmap）    nsmap = root.nsmap or {}    required_prefixes = ["office", "draw", "presentation", "text", "xlink", "svg"]    for p in required_prefixes:        if p not in nsmap.values() and p not in nsmap:            # lxmlはprefix->URI のdict（値）で照合される場合あり            # 厳密にprefix名存在も確認            if p not in (nsmap.keys()):                results.add("WARN", "NS_MISSING", f"名前空間接頭辞 {p} の宣言が見つかりません（実際は暗黙URI一致の可能性あり）")    body = root.find("office:body", namespaces=NS)    if body is None:        results.add("FAIL", "CONTENT_BODY", "office:body がありません")        return None, None    pres = body.find("office:presentation", namespaces=NS)    if pres is None:        results.add("FAIL", "CONTENT_PRESENTATION", "office:presentation がありません")        return None, None    pages = pres.findall("draw:page", namespaces=NS)    n_pages = len(pages)    results.add("PASS", "PAGES_COUNT", f"draw:page: {n_pages} 枚")    if expected_pages is not None and n_pages != expected_pages:        results.add("WARN", "PAGES_UNEXPECTED", f"期待枚数 {expected_pages} に一致しません（実数: {n_pages}）")    return tree, pagesdef check_styles_xml(zf: zipfile.ZipFile, results: Results):    tree = load_xml_from_zip(zf, "styles.xml", results)    if tree is None:        return None    root = tree.getroot()    if root.tag != f"{{{NS['office']}}}document-styles":        results.add("FAIL", "STYLES_ROOT", "styles.xml のルートが office:document-styles ではありません")    # master-page と page-layout の関係    masters = root.findall(".//style:master-page", namespaces=NS)    if not masters:        results.add("FAIL", "MASTER_MISSING", "style:master-page がありません")        return tree    else:        names = [m.get(f"{{{NS['style']}}}name") for m in masters]        results.add("PASS", "MASTER_FOUND", f"master-page: {', '.join(n for n in names if n)}")    # page-layout定義を収集    layouts = {pl.get(f"{{{NS['style']}}}name"): pl               for pl in root.findall(".//style:page-layout", namespaces=NS)}    if not layouts:        results.add("FAIL", "PAGELAYOUT_MISSING", "style:page-layout がありません")    else:        results.add("PASS", "PAGELAYOUT_FOUND", f"page-layout 定義数: {len(layouts)}")    # 16:9 チェック（参照されるlayoutについて）    for m in masters:        plname = m.get(f"{{{NS['style']}}}page-layout-name")        if not plname:            results.add("WARN", "MASTER_NO_LAYOUT", "master-page に page-layout-name がありません")            continue        if plname not in layouts:            results.add("FAIL", "LAYOUT_NOT_FOUND", f"masterが参照する page-layout が定義されていません: {plname}")            continue        pl = layouts[plname]        props = pl.find(".//style:page-layout-properties", namespaces=NS)        if props is None:            results.add("WARN", "LAYOUT_NO_PROPS", f"page-layout {plname} に style:page-layout-properties がありません")            continue        w = parse_length_to_cm(props.get(f"{{{NS['fo']}}}page-width"))        h = parse_length_to_cm(props.get(f"{{{NS['fo']}}}page-height"))        if w and h and isfinite(w) and isfinite(h):            ratio = w / h            # 16:9 ~ 1.777... を ±2% 範囲で許容            if abs(ratio - (16/9)) <= 0.02:                results.add("PASS", "ASPECT_16_9", f"page-layout {plname} は16:9比率（{w:.2f}cm x {h:.2f}cm, ratio={ratio:.3f}）")            else:                results.add("WARN", "ASPECT_NOT_16_9", f"page-layout {plname} の比率が16:9から外れています（{w:.2f}cm x {h:.2f}cm, ratio={ratio:.3f}）")        else:            results.add("WARN", "ASPECT_UNKNOWN", f"page-layout {plname} に幅/高さが設定されていません")    return treedef check_pages_and_images(zf: zipfile.ZipFile, pages, manifest_present, results: Results,                           require_captions=False):    """    - draw:frame > draw:image 構造    - xlink:href が Pictures/ を相対参照    - svg:x/y/width/height 単位付き    - 画像実体/manifest と整合    - （任意）画像ページにキャプション枠(draw:text-box)がある    - 互換性: presentation:animations / event-listener 未使用    """    if pages is None:        return    used_images = set()    any_animations = False    for idx, page in enumerate(pages, start=1):        page_ok = True        # 互換性: アニメ/イベント        if page.find(".//presentation:animations", namespaces=NS) is not None:            any_animations = True            results.add("WARN", "ANIMATIONS_PRESENT", f"{idx}枚目: presentation:animations を使用しています")        if page.find(".//presentation:event-listener", namespaces=NS) is not None:            any_animations = True            results.add("WARN", "EVENT_LISTENER_PRESENT", f"{idx}枚目: presentation:event-listener を使用しています")        # 画像チェック        images = page.findall(".//draw:image", namespaces=NS)        frames = page.findall(".//draw:frame", namespaces=NS)        # draw:image は frame の子であることを推奨        for img in images:            parent = img.getparent()            if parent is None or etree.QName(parent).localname != "frame":                page_ok = False                results.add("FAIL", "IMAGE_NO_FRAME", f"{idx}枚目: draw:image が draw:frame 内にありません")            href = img.get(f"{{{NS['xlink']}}}href")            if not href:                page_ok = False                results.add("FAIL", "IMAGE_NO_HREF", f"{idx}枚目: 画像の xlink:href がありません")            else:                if not href.startswith("Pictures/"):                    results.add("WARN", "IMAGE_PATH", f"{idx}枚目: 画像が相対パス(Pictures/)でありません: {href}")                used_images.add(href)                # 実体の存在                try:                    zf.getinfo(href)                except KeyError:                    page_ok = False                    results.add("FAIL", "IMAGE_MISSING_FILE", f"{idx}枚目: 画像ファイルがZIPに存在しません: {href}")                # manifestに存在                if manifest_present is not None and href not in manifest_present:                    results.add("WARN", "IMAGE_NOT_IN_MANIFEST", f"{idx}枚目: 画像が manifest に未掲載: {href}")        # フレームの座標/サイズ（単位付き）        for fr in frames:            for attr in ("x", "y", "width", "height"):                val = fr.get(f"{{{NS['svg']}}}{attr}")                if val is None:                    results.add("WARN", "FRAME_NO_GEOM", f"{idx}枚目: frame に svg:{attr} がありません")                else:                    cm = parse_length_to_cm(val)                    if cm is None:                        results.add("WARN", "FRAME_BAD_UNIT", f"{idx}枚目: frame の svg:{attr} の単位/形式が不正: {val}")        # キャプション（任意）        if require_captions and images:            has_caption = page.find(".//draw:text-box", namespaces=NS) is not None            if not has_caption:                results.add("WARN", "NO_CAPTION", f"{idx}枚目: 図表にキャプション枠がありません")        if page_ok:            results.add("PASS", "PAGE_OK", f"{idx}枚目: 画像/構造チェックOK")    # 未使用/未参照 画像（任意報告）    # Pictures/ 内の画像で used_images に入っていないものを警告    pic_names = {i.filename for i in zf.infolist() if i.filename.startswith("Pictures/")}    unused = sorted(pic for pic in pic_names if pic not in used_images)    if unused:        results.add("WARN", "UNUSED_IMAGES", f"参照されていない画像があります: {', '.join(unused[:10])}"                                              + (" ..." if len(unused) > 10 else ""))def check_master_on_pages(pages, styles_tree, results: Results, required_master=None):    # 各 draw:page が master-page-name を持ち、styles.xml に実在するか    if pages is None or styles_tree is None:        return    root = styles_tree.getroot()    masters = {m.get(f"{{{NS['style']}}}name"): m               for m in root.findall(".//style:master-page", namespaces=NS)}    for idx, page in enumerate(pages, start=1):        mp = page.get(f"{{{NS['draw']}}}master-page-name")        if not mp:            results.add("WARN", "PAGE_NO_MASTER", f"{idx}枚目: master-page-name が設定されていません")        else:            if mp not in masters:                results.add("FAIL", "MASTER_NOT_DEFINED", f"{idx}枚目: 参照する master-page が styles.xml にありません: {mp}")            else:                results.add("PASS", "PAGE_MASTER_OK", f"{idx}枚目: master-page {mp} を参照")        if required_master and mp and mp != required_master:            results.add("WARN", "MASTER_UNEXPECTED", f"{idx}枚目: 期待と異なる master-page を参照（{mp}）")def check_meta_settings(zf: zipfile.ZipFile, results: Results):    # meta.xml 基本要素    tree = load_xml_from_zip(zf, "meta.xml", results)    if tree:        root = tree.getroot()        meta = root.find("office:meta", namespaces=NS)        if meta is None:            results.add("WARN", "META_BODY", "meta.xml に office:meta がありません")        else:            title = meta.find("dc:title", namespaces=NS)            creator = meta.find("dc:creator", namespaces=NS)            cdate = meta.find("meta:creation-date", namespaces=NS)            if title is None:                results.add("WARN", "META_TITLE", "dc:title が未設定")            if creator is None:                results.add("WARN", "META_CREATOR", "dc:creator が未設定")            if cdate is None:                results.add("WARN", "META_CDATE", "meta:creation-date が未設定")            results.add("PASS", "META_OK", "meta.xml の基本項目チェック完了")    # settings.xml 構文のみ    tree2 = load_xml_from_zip(zf, "settings.xml", results)    if tree2:        results.add("PASS", "SETTINGS_OK", "settings.xml パースOK")def main():    ap = argparse.ArgumentParser(description="ODP バリデーション (Googleスライド互換チェック含む)")    ap.add_argument("odp", help="検証対象の .odp パス")    ap.add_argument("--expected-pages", type=int, default=None, help="期待するスライド枚数（例: 12）")    ap.add_argument("--master", default=None, help="期待する master-page 名（例: Default）")    ap.add_argument("--require-captions", action="store_true", help="画像スライドにキャプション枠が必須")    args = ap.parse_args()    results = Results()    try:        with zipfile.ZipFile(args.odp, "r") as zf:            # ZIP構造            check_zip_structure(zf, results)            # manifest            entries, present = check_manifest(zf, results)            # content.xml            content_tree, pages = check_content_xml(zf, results, expected_pages=args.expected_pages)            # styles.xml            styles_tree = check_styles_xml(zf, results)            # 各ページ & 画像            check_pages_and_images(zf, pages, present, results, require_captions=args.require_captions)            # master-page 参照            check_master_on_pages(pages, styles_tree, results, required_master=args.master)            # meta/settings            check_meta_settings(zf, results)    except zipfile.BadZipFile:        results.add("FAIL", "BAD_ZIP", "ODPは壊れているかZIPとして不正です")    except Exception as e:        results.add("FAIL", "UNEXPECTED", f"想定外のエラー: {e}")    # 出力    results.dump(sys.stdout)    st = results.stats()    print("\n=== SUMMARY ===")    print(f"PASS: {st.get('PASS',0)}  WARN: {st.get('WARN',0)}  FAIL: {st.get('FAIL',0)}")    sys.exit(1 if results.had_fail() else 0)if __name__ == "__main__":    main()